<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.42">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Justin Zhou, Wendy Zhu, Lucy Cao, Janice Jiang, Ella Yang, Cecilia Jiang">
<meta name="dcterms.date" content="2025-10-29">

<title>Biomarkers of ASD</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="report_files/libs/clipboard/clipboard.min.js"></script>
<script src="report_files/libs/quarto-html/quarto.js"></script>
<script src="report_files/libs/quarto-html/popper.min.js"></script>
<script src="report_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="report_files/libs/quarto-html/anchor.min.js"></script>
<link href="report_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="report_files/libs/quarto-html/quarto-syntax-highlighting-2f5df379a58b258e96c21c0638c20c03.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="report_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="report_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="report_files/libs/bootstrap/bootstrap-4bba5e2a3696111c7f0c20ecb83df5d3.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Biomarkers of ASD</h1>
<p class="subtitle lead">If you want a subtitle put it here</p>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Justin Zhou, Wendy Zhu, Lucy Cao, Janice Jiang, Ella Yang, Cecilia Jiang </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Updated</div>
    <div class="quarto-title-meta-contents">
      <p class="date">October 29, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<p>Use this as a template. Keep the headers and remove all other text. In all, your report can be quite short. When it is complete, render and then push changes to your team repository.</p>
<section id="abstract" class="level2">
<h2 class="anchored" data-anchor-id="abstract">Abstract</h2>
<p>’‘’Write a brief one-paragraph abstract that describes the contents of your write-up.’’’</p>
<p>This report revisits a public serum-proteomics dataset originally used to study potential early-detection biomarkers for autism spectrum disorder (ASD). We stress-test the analysis by varying key design choices that plausibly change which proteins look predictive. First, we justify working on the log scale and examine the influence of trimming versus not trimming outliers (Tasks 1–2). Next, we vary the feature-selection protocol by moving all selection onto a training split, expanding the number of top proteins per method, and replacing a hard intersection with a fuzzy one (Task 3). Finally, we seek either a simpler panel with comparable accuracy or an alternative panel with improved accuracy (Task 4), benchmarking against the in-class baseline. Throughout, we rely on figures and tables produced by team scripts and emphasize short, decision-oriented takeaways.</p>
</section>
<section id="dataset" class="level2">
<h2 class="anchored" data-anchor-id="dataset">Dataset</h2>
<p>’‘’Write a brief data description, including: how data were obtained; sample characteristics; variables measured; and data preprocessing. This can be largely based on the source paper and should not exceed 1-2 paragraphs.’’’</p>
<p>Source and access. Data are the public matrix from Hewitson et al.&nbsp;(2021, PLOS ONE; accessed for the course in Aug 2022). Following the course convention, we keep the 192 unidentified proteins that the paper dropped, to make the screening step more demanding.</p>
<p>Sample and variables. The analytic file contains 156 participants: ASD = 76, TD/Control = 78, with 2 unlabeled rows in the provided file. Each row is a participant; columns are serum protein intensities plus a small number of metadata fields (e.g., Group) and a clinical severity variable (ADOS Total Score). There are 1,317 protein features in this copy. Roughly 1.3% of protein cells are missing prior to preprocessing. Intensities are right-skewed and vary on a multiplicative scale, motivating a log transform; missingness is handled consistently with the team’s preprocessing script.</p>
</section>
<section id="summary-of-published-analysis" class="level2">
<h2 class="anchored" data-anchor-id="summary-of-published-analysis">Summary of published analysis</h2>
<p>’‘’Summarize the methodology of the paper in 1-3 paragraphs. You need not explain the methods in depth as we did in class; just indicate what methods were used and how they were combined. If possible, include a diagram that depicts the methodological design. (Quarto has support for <a href="https://quarto.org/docs/authoring/diagrams.html">GraphViz and Mermaid flowcharts</a>.) Provide key results: the proteins selected for the classifier and the estimated accuracy.’’’</p>
<p>The paper builds a classifier in two stages: screening and model fitting. First, the serum protein intensities are preprocessed (log transformation; handling of extreme values) to make distributions more comparable across proteins. Next, the authors score each protein using three complementary views: (1) univariate group comparisons (ASD vs.&nbsp;control, one protein at a time), (2) association with clinical severity (e.g., correlation with ADOS or a similar measure), and (3) random-forest variable importance to capture multivariate, nonlinear signal. Proteins that score well across these views form a core set (via overlap across methods, either a strict intersection or “appears in at least 2 of 3”). The core is then augmented into an “optimal” panel by adding nearby candidates until classifier performance (measured on held-out data) stops improving.</p>
<p>With a candidate panel in hand, the study fits simple models—typically logistic regression (sometimes with forward selection) and random forest—and evaluates them on held-out data with repeated splits. Performance is summarized primarily by AUROC and overall accuracy, reported alongside the final list of proteins in the panel. In other words, the screening stage decides what to measure, and the classifier stage tests how well those choices predict in data that were not used for selection.</p>
<p>Key results to report in this write-up: The core set comprised [ ], which after augmentation yielded the final (“optimal”) panel of [ ]. On held-out evaluation, the paper reports AUROC ≈ [__] and accuracy ≈ [__].</p>
</section>
<section id="findings" class="level2">
<h2 class="anchored" data-anchor-id="findings">Findings</h2>
<p>Summarize your findings here. I’ve included some subheaders in a way that seems natural to me; you can structure this section however you like.</p>
<section id="impact-of-preprocessing-and-outliers" class="level3">
<h3 class="anchored" data-anchor-id="impact-of-preprocessing-and-outliers">Impact of preprocessing and outliers</h3>
<p>Exploratory plots of the raw serum protein levels showed heavy right-skewness across nearly all proteins, with long tails and large variance differences. This justified the use of a log transformation, which compresses extreme high values and makes the distributions approximately symmetric and comparable across proteins. After log-scaling, densities became much smoother and centered, enabling more stable downstream inference.</p>
<p>When we repeated preprocessing <em>without</em> trimming (|z| &gt; 3), we found that a few participants had unusually high numbers of extreme protein values. Counting outliers per subject revealed that TD (typically developing) participants showed slightly higher average counts (mean = 17.6 ± SE ≈ 3.7) than ASD participants (mean = 13.3 ± SE ≈ 2.3), although medians were identical (8.5). This suggests that outlier frequency is not strongly group-specific but that several TD subjects exhibit more variable protein profiles. Removing trimming therefore increases within-group heterogeneity but does not substantially change group-level trends.</p>
</section>
<section id="methodological-variations" class="level3">
<h3 class="anchored" data-anchor-id="methodological-variations">Methodological variations</h3>
<p>We systematically examined how three core methodological changes—training-based feature selection, expanding the number of top-ranked proteins, and using a fuzzy rather than strict intersection—affected the identification of predictive biomarkers for ASD. These experiments aimed to test the robustness of our pipeline and identify configurations that balance accuracy with interpretability.</p>
<p><strong>1. Selection Conducted Only on the Training Partition</strong></p>
<p>In the baseline workflow, all available data were used for protein screening, which can unintentionally allow information from the test set to influence feature selection. To prevent this <strong>information leakage</strong>, we modified the process so that the entire selection stage was performed using only the <strong>training partition (80%)</strong>, keeping the remaining <strong>20%</strong> of the data completely separate for final evaluation.<br>
</p>
<p>This adjustment produced slightly lower but more realistic performance metrics, confirming that prior results likely benefited from mild overfitting. Despite this correction, the model still achieved strong predictive ability—an <strong>accuracy of about 77%</strong> and <strong>AUROC around 0.89</strong>—showing that the predictive signal remained robust even when all model choices were confined to training data. This modification improved the credibility of the results and better reflects performance expected in new, unseen samples.</p>
<p><strong>2. Increasing the Number of Top Predictive Proteins</strong></p>
<p>We next tested the sensitivity of performance to the number of selected features. The initial in-class analysis capped each selection method at the <strong>top 10 proteins</strong>; we expanded this range to <strong>10–20 proteins</strong> and repeated the entire pipeline.<br>
</p>
<p>Performance improved steadily up to approximately <strong>n = 17</strong>, where both accuracy and AUROC peaked. AUROC rose from roughly <strong>0.79 at n = 10 to 0.89 at n = 17</strong>, while accuracy stabilized near 0.77. Beyond 17 proteins, gains diminished and in some cases reversed, indicating that adding weaker predictors introduced noise and redundancy. These results suggest that including <strong>a slightly larger subset of top-performing proteins</strong> can capture additional variation in ASD vs.&nbsp;TD profiles, but overly broad panels dilute signal and offer no further benefit.</p>
<section id="hard-vs.-fuzzy-intersection-approaches" class="level4">
<h4 class="anchored" data-anchor-id="hard-vs.-fuzzy-intersection-approaches">3. Hard vs.&nbsp;Fuzzy Intersection Approaches</h4>
<p>Different team members implemented alternative strategies for combining the top protein sets identified by the t-test and random forest screens. One teammate used a <strong>hard intersection</strong>, keeping only the proteins that appeared in both ranking lists. The other applied a <strong>fuzzy intersection (union)</strong>, combining all proteins that appeared in either list.</p>
<p>The <strong>hard intersection</strong> was intentionally conservative: it focused on proteins that were consistently important across both statistical and machine-learning criteria. However, this strict overlap produced a small feature set and lower predictive performance, with AUROC values around <strong>0.10–0.12</strong> in our tests. This suggests that the few proteins passing both filters captured limited group variation and that some valuable information was lost by enforcing such strict agreement.</p>
<p>By contrast, the <strong>fuzzy intersection (union)</strong> approach yielded a broader feature set that incorporated complementary biological signals—univariate differences from the t-tests and nonlinear interaction effects from random forest importance scores. This approach achieved substantially stronger model performance, with AUROC values improving to <strong>0.79–0.89</strong>, and showed more stable results across multiple random splits. Although this inclusion strategy risks introducing mildly redundant predictors, it better captured the complex and multidimensional nature of the ASD–TD contrast.</p>
<p>Taken together, the two methods illustrate a key trade-off between <strong>parsimony and sensitivity</strong>. The hard intersection ensures consistency but can overlook unique, method-specific markers, while the fuzzy intersection sacrifices some strictness to achieve higher discriminative accuracy and biological completeness.</p>
</section>
<section id="summary-of-effects" class="level4">
<h4 class="anchored" data-anchor-id="summary-of-effects">Summary of Effects</h4>
<p>Overall, our team’s experiments show how methodological choices can shift both statistical and practical outcomes. Performing all selection steps on the <strong>training partition</strong> yields more credible accuracy estimates by preventing overfitting. Expanding the <strong>number of top proteins</strong> to around <strong>15–17</strong> maximizes performance before diminishing returns appear. Finally, comparing <strong>hard versus fuzzy intersections</strong> demonstrates that a more inclusive combination rule improves generalization and predictive signal capture.</p>
<p><strong>Figure X.</strong><br>
</p>
<p><em>Comparison of ROC–AUC trends and intersection strategies.</em><br>
</p>
<p>The ROC–AUC results for protein panels ranging from 10 to 20 features show that performance improves steadily up to about 17 features. The <strong>fuzzy intersection (union)</strong> approach consistently outperformed the <strong>hard intersection</strong>, achieving AUC values close to 0.89 versus near 0.10–0.12 for the strict overlap. These findings highlight that combining complementary feature-selection methods, while maintaining proper training–testing separation, offers the most reliable and interpretable classification framework.</p>
<p>Task 4</p>
<p>Building on the previous sensitivity tests, we aimed to refine our model to achieve strong predictive performance with greater interpretability. Specifically, we compared two goals: developing a <strong>simpler panel</strong> that performs comparably to the in-class model, and constructing an <strong>alternative panel</strong> that improves classification accuracy through methodological adjustments.</p>
</section>
<section id="a-simpler-panel-with-comparable-accuracy" class="level4">
<h4 class="anchored" data-anchor-id="a-simpler-panel-with-comparable-accuracy">1. A Simpler Panel with Comparable Accuracy</h4>
<p>To explore whether a smaller set of proteins could maintain similar predictive ability, we gradually reduced the number of selected features from 17 down to smaller subsets. We found that a <strong>six-protein panel</strong> preserved nearly all of the discriminative strength of the full model. The simplified classifier achieved an <strong>AUROC of approximately 0.86</strong> and an <strong>accuracy of about 0.75</strong>, compared with <strong>0.89 and 0.77</strong>, respectively, for the 17-protein version.<br>
</p>
<p>The small decrease in AUROC (≈0.03) was outweighed by the large reduction in model complexity, making the simpler model more efficient and easier to interpret. This result suggests that a focused set of biomarkers captures most of the underlying biological separation between ASD and TD groups, with minimal loss of predictive power.</p>
</section>
<section id="an-alternative-panel-with-improved-accuracy" class="level4">
<h4 class="anchored" data-anchor-id="an-alternative-panel-with-improved-accuracy">2. An Alternative Panel with Improved Accuracy</h4>
<p>We also tested an <strong>alternative feature set</strong> derived from the fuzzy intersection and training-split approach. This version incorporated the top proteins identified by either the t-test or random forest methods across multiple random splits, emphasizing cross-method agreement and stability.<br>
</p>
<p>The resulting <strong>17-protein union panel</strong> achieved an <strong>AUROC of 0.89 and overall accuracy of 0.77</strong>, both exceeding the in-class baseline of approximately 0.75 and 0.70, respectively. The model balanced sensitivity (≈0.86) and specificity (≈0.71), showing improved discrimination while avoiding overfitting. This outcome demonstrates that allowing complementary selection criteria to contribute unique information yields a more generalizable and biologically plausible classifier.</p>
</section>
<section id="summary-and-interpretation" class="level4">
<h4 class="anchored" data-anchor-id="summary-and-interpretation">3. Summary and Interpretation</h4>
<p>In sum, both strategies proved effective in different ways. The <strong>simpler six-protein panel</strong> offers nearly equivalent performance with substantial gains in interpretability and practical feasibility, ideal for clinical follow-up or assay development. The <strong>alternative union-based panel</strong>, while larger, maximizes accuracy and stability across multiple validation runs.<br>
</p>
<p>Together, these results show that predictive performance in proteomic classification does not scale linearly with model complexity. Well-chosen smaller panels can remain powerful, while inclusive feature-combination strategies capture richer signals without overfitting.</p>
</section>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>